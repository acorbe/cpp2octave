# cpp2octave
### C++ Automated generation of octave/matlab scripts/data at runtime 

**Author:** [Alessandro Corbetta](http://corbetta.phys.tue.nl), 2012-2013 (circa)

This library aims at speeding up data post-processing in C++ scientific applications by having post-processing scripts being generated by the C++ runtime itself.

With a template-based syntax, at run-time it creates, in tandem, octave scripts which can interact with C++ array data. C++ arrays get seamlessly dumped into data files that the octave code reads. 

This code has been written in 2012, one of the aims of this project was testing some of the new C++11 features. As such is experimental and not really maintained. It follows some code design concepts I developed for the simulations/visualizations of the paper [Bruno, Corbetta, Tosin. From individual behaviour to an evaluation of the collective evolution of crowds along footbridges
J. Engrg. Math., 101(1):153-173, 2016](http://link.springer.com/article/10.1007/s10665-016-9852-z) and my work at Los Alamos.

My library [Autogpy](https://github.com/acorbe/autogpy) follows loosely the same concept but for the code pair python/gnuplot instead of C++/octave. Autogpy is currently developed.


## Example

The following cpp code

```cpp
// An octave script named "myOct.m" will be initialized in the default path.
// A directory named support_myOct will be created as well to contain data and support files.
cpp2octave::cpp2oct myCore("myOct");

// "Hello world!" is displayed by the console
myCore.f_disp("Hello World!");
// RESULT in myOct.m: disp( 'Hello World!' );

// The latter is indeed a shortcut of the more general call
myCore.oct_f_call("disp","Hello World! 2");
// RESULT in myOct.m: disp( 'Hello World!' );

// You can instantiate octave objects, as the following object "ob".
// "Ob" will serve as an handler/pointer to the octave object "obj0_" automatically created. Indeed you don't need to consider "obj0_", in the cpp side you will use just "ob".
c2o_obj ob = myCore.oct_new_obj_base();

// You can ask octave to calculate a 3x3 random matrix and to assign it to the object handled by ob.
myCore.oct_f_call(ob,"rand",3);
// RESULT in myOct.m: obj0_ = rand( 3 );
//
// Let's display the matrix
myCore.f_disp(ob);
// RESULT in myOct.m: disp( obj0_ );

// You may want a 3x4 random matrix. Nothing easier...
myCore.oct_f_call(ob,"rand",3,4);
// RESULT in myOct.m: obj0_ = rand( 3 , 4 );
//
// Again, let's display the matrix
myCore.f_disp(ob);
```

produces the octave script
```octave
disp( 'Hello World!' );
disp( 'Hello World! 2' );
obj0_ = rand( 3 );
disp( obj0_ );
obj0_ = rand( 3 , 4 );
disp( obj0_ );
```

More advanced usage is in the file [[cpp2octave.cpp](cpp2octave.cpp)] which produces [[this output](example_output)].
